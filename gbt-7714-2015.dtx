% \iffalse meta-comment
%
% Copyright (C) 2016 by Zeping Lee <zepinglee AT gmail.com>
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.2 of this license or (at your option) any later
% version. The latest version of this license is in:
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.2 or later is part of all distributions of
% LaTeX version 1999/12/01 or later.
%
% This file is derived from both `btxbst.doc' by Oren Patashnik and
% `plainnat.bst' by Patrick W Daly.
%
%<*internal>
\iffalse
\fi
\begingroup
    \def\nameoflatex{LaTeX2e}
\expandafter\endgroup\ifx\nameoflatex\fmtname\else
\csname fi\endcsname
%</internal>
%<*install>
\input docstrip.tex
\preamble

Copyright (C) 2016-\the\year by Zeping Lee <zepinglee AT gmail.com>

This file may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either
version 1.2 of this license or (at your option) any later
version. The latest version of this license is in:

    http://www.latex-project.org/lppl.txt

and version 1.2 or later is part of all distributions of
LaTeX version 1999/12/01 or later.

This BibTeX style file is derived from `plainnat.bst' by Patrick W Daly,
which was designed for use with the `natbib.sty' package.

\endpreamble
\keepsilent
\askforoverwritefalse
\nopostamble
\generate{
    \file{gbt-7714-2015-author-year.bst}{\from{\jobname.dtx}{authoryear}}
    \file{gbt-7714-2015-numerical.bst}{\from{\jobname.dtx}{numerical}}
}
\Msg{* Happy TeXing!}
\endbatchfile
%</install>
%<*internal>
\fi
%</internal>
%<*driver>
\ProvidesFile{gbt-7714-2015.dtx}[2016/04/13 v0.9 GB/T 7714-2015 BibTeX style]
\documentclass{ltxdoc}
\RequirePackage[paper=a4paper,margin=1in]{geometry}
\usepackage{hypdoc}
\hypersetup{allcolors=blue}
\usepackage[UTF8,scheme=plain]{ctex}
\setmainfont{Times}
\setsansfont{Helvetica}[Scale=MatchLowercase]
\setmonofont{Menlo}[Scale=MatchLowercase]
\usepackage{listings}
\lstset{gobble=2,basicstyle=\ttfamily,frame=single,language=bash}
\EnableCrossrefs
\CodelineIndex
\RecordChanges

\begin{document}
    \DocInput{gbt-7714-2015.dtx}
    \PrintChanges
    \PrintIndex
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \GetFileInfo{gbt-7714-2015.dtx}
%
% \title{GB/T 7714-2015 \BibTeX{} style}
% \author{Zeping Lee\thanks{zepinglee AT gmail.com}}
% \date{\filedate\qquad\fileversion}
% \maketitle
%
% \changes{v0.9}{2016/04/13}{Beta release.}
%
% \StopEventually{}
%
% \section{Fields and entry strings}
%
%    \begin{macrocode}
%<*authoryear|numerical>
%    \end{macrocode}
%
%    \begin{macrocode}
ENTRY
  { address
    author
    booktitle
    chapter
    citedate
    doi
    eid
    edition
    editor
    editdate
    howpublished
    institution
    isbn
    issn
    journal
    key
    language
    mark
    media
    month
    note
    number
    organization
    pages
%<authoryear>    pinyin
    publisher
    school
    series
    title
    translator
    type
    url
    volume
    year
  }
  { lang }
%    \end{macrocode}
%
% These string entry variables are used to form the citation label.
% In a storage pinch, sort.label can be easily computed on the fly.
%
%    \begin{macrocode}
  { label extra.label sort.label short.list }

%    \end{macrocode}
%
% \section{Entry functions}
% Each entry function starts by calling output.bibitem, to write the
% |\bibitem| and its arguments to the .BBL file.  Then the various fields
% are formatted and printed by output or output.check.  Those functions
% handle the writing of separators (commas, periods, |\newblock|'s),
% taking care not to do so when they are passed a null string.
% Finally, fin.entry is called to add the final period and finish the
% entry.
%
% A bibliographic reference is formatted into a number of `blocks':
% in the open format, a block begins on a new line and subsequent
% lines of the block are indented.  A block may contain more than
% one sentence (well, not a grammatical sentence, but something to
% be ended with a sentence ending period).  The entry functions should
% call new.block whenever a block other than the first is about to be
% started.  They should call new.sentence whenever a new sentence is
% to be started.  The output functions will ensure that if two
% new.sentence's occur without any non-null string being output between
% them then there won't be two periods output.  Similarly for two
% successive new.block's.
%
% The output routines don't write their argument immediately.
% Instead, by convention, that argument is saved on the stack to be
% output next time (when we'll know what separator needs to come
% after it).  Meanwhile, the output routine has to pop the pending
% output off the stack, append any needed separator, and write it.
%
% To tell which separator is needed, we maintain an output.state.
% It will be one of these values:
%       before.all              just after the |\bibitem|
%       mid.sentence            in the middle of a sentence: comma needed
%                                       if more sentence is output
%       after.sentence          just after a sentence: period needed
%       after.block             just after a block (and sentence):
%                                       period and |\newblock| needed.
% Note: These styles don't use after.sentence
%
% VAR: output.state : INTEGER           -- state variable for output
%
% The output.nonnull function saves its argument (assumed to be nonnull)
% on the stack, and writes the old saved value followed by any needed
% separator.  The ordering of the tests is decreasing frequency of
% occurrence.
%
% \begin{lstlisting}
% output.nonnull(s) ==
%  BEGIN
%       s := argument on stack
%       if output.state = mid.sentence then
%           write$(pop() * ", ")
%                 -- "pop" isn't a function: just use stack top
%       else
%           if output.state = after.block then
%               write$(add.period$(pop()))
%               newline$
%               write$("\newblock ")
%           else
%               if output.state = before.all then
%                   write$(pop())
%               else        -- output.state should be after.sentence
%                   write$(add.period$(pop()) * " ")
%               fi
%           fi
%           output.state := mid.sentence
%       fi
%       push s on stack
%  END
% \end{lstlisting}
%
% The output function calls output.nonnull if its argument is non-empty;
% its argument may be a missing field (thus, not necessarily a string)
%
% \begin{lstlisting}
% output(s) ==
%  BEGIN
%       if not empty$(s) then output.nonnull(s)
%       fi
%  END
% \end{lstlisting}
%
% The output.check function is the same as the output function except that, if
% necessary, output.check warns the user that the t field shouldn't be empty
% (this is because it probably won't be a good reference without the field;
% the entry functions try to make the formatting look reasonable even when
% such fields are empty).
%
% \begin{lstlisting}
% output.check(s,t) ==
%  BEGIN
%       if empty$(s) then
%           warning$("empty " * t * " in " * cite$)
%       else output.nonnull(s)
%       fi
%  END
% \end{lstlisting}
%
% The output.bibitem function writes the |\bibitem| for the current entry
% (the label should already have been set up), and sets up the separator
% state for the output functions.  And, it leaves a string on the stack
% as per the output convention.
%
% \begin{lstlisting}
% output.bibitem ==
%  BEGIN
%       newline$
%       write$("\bibitem[")     % for alphabetic labels,
%       write$(label)           % these three lines
%       write$("]{")            % are used
%       write$("\bibitem{")             % this line for numeric labels
%       write$(cite$)
%       write$("}")
%       push "" on stack
%       output.state := before.all
%  END
% \end{lstlisting}
%
% The fin.entry function finishes off an entry by adding a period to the
% string remaining on the stack.  If the state is still before.all
% then nothing was produced for this entry, so the result will look bad,
% but the user deserves it. (We don't omit the whole entry because the
% entry was cited, and a bibitem is needed to define the citation label.)
%
% \begin{lstlisting}
% fin.entry ==
%  BEGIN
%       write$(add.period$(pop()))
%       newline$
%  END
% \end{lstlisting}
%
% The new.block function prepares for a new block to be output, and
% new.sentence prepares for a new sentence.
%
% \begin{lstlisting}
% new.block ==
%  BEGIN
%       if output.state <> before.all then
%           output.state := after.block
%       fi
%  END
% \end{lstlisting}
%
% \begin{lstlisting}
% new.sentence ==
%  BEGIN
%       if output.state <> after.block then
%           if output.state <> before.all then
%               output.state :=  after.sentence
%           fi
%       fi
%  END
% \end{lstlisting}
%
%    \begin{macrocode}
INTEGERS { output.state before.all mid.sentence after.sentence after.block }
INTEGERS { lang.zh lang.ja lang.en lang.ru lang.default }

FUNCTION {init.state.consts}
{ #0 'before.all :=
  #1 'mid.sentence :=
  #2 'after.sentence :=
  #3 'after.block :=
  #4 'lang.zh :=
  #5 'lang.ja :=
  #1 'lang.en :=
  #3 'lang.ru :=
  #0 'lang.default :=
}

%    \end{macrocode}
%
% the variables s and t are temporary string holders
%
%    \begin{macrocode}
STRINGS { s t }

FUNCTION {debug}
{ 's :=
  duplicate$
  "DEBUG: " s * " -> `" *
  swap$ * "'" *
  top$
}

FUNCTION {debug.int}
{ 's :=
  duplicate$ int.to.str$
  "DEBUG: " s * " == " *
  swap$ *
  top$
}

FUNCTION {output.nonnull}
{ 's :=
  output.state mid.sentence =
    { ", " * write$ }
    { output.state after.block =
        { add.period$ write$
          newline$
          "\newblock " write$
        }
        { output.state before.all =
            'write$
            { add.period$ " " * write$ }
          if$
        }
      if$
      mid.sentence 'output.state :=
    }
  if$
  s
}

FUNCTION {output}
{ duplicate$ empty$
    'pop$
    'output.nonnull
  if$
}

FUNCTION {output.after}
{ 't :=
  duplicate$ empty$
    'pop$
    { 's :=
      output.state mid.sentence =
        { t * write$ }
        { output.state after.block =
            { t * write$
              newline$
              "\newblock " write$
            }
            { output.state before.all =
                'write$
                { t * write$ }
              if$
            }
          if$
          mid.sentence 'output.state :=
        }
      if$
      s
    }
  if$
}

FUNCTION {punct.colon}
{ ": "
}

FUNCTION {punct.slash}
{ "//"
}

FUNCTION {punct.space}
{ " "
}

FUNCTION {output.check}
{ 't :=
  duplicate$ empty$
    { pop$ "empty " t * " in " * cite$ * warning$ }
    'output.nonnull
  if$
}

%    \end{macrocode}
%
% This function finishes all entries.
%
%    \begin{macrocode}
FUNCTION {fin.entry}
{ add.period$
  write$
  newline$
}

FUNCTION {new.block}
{ output.state before.all =
    'skip$
    { after.block 'output.state := }
  if$
}

FUNCTION {new.sentence}
{ output.state after.block =
    'skip$
    { output.state before.all =
        'skip$
        { after.sentence 'output.state := }
      if$
    }
  if$
}

%    \end{macrocode}
%
% These three functions pop one or two (integer) arguments from the stack
% and push a single one, either 0 or 1.
% The |'skip$| in the `and' and `or' functions are used because
% the corresponding |if$| would be idempotent
%
%    \begin{macrocode}
FUNCTION {not}
{   { #0 }
    { #1 }
  if$
}

FUNCTION {and}
{   'skip$
    { pop$ #0 }
  if$
}

FUNCTION {or}
{   { pop$ #1 }
    'skip$
  if$
}

%    \end{macrocode}
%
% Sometimes we begin a new block only if the block will be big enough.  The
% new.block.checka function issues a new.block if its argument is nonempty;
% new.block.checkb does the same if either of its TWO arguments is nonempty.
%
%    \begin{macrocode}
FUNCTION {new.block.checka}
{ empty$
    'skip$
    'new.block
  if$
}

FUNCTION {new.block.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.block
  if$
}

%    \end{macrocode}
%
% The new.sentence.check functions are analogous.
%
%    \begin{macrocode}
FUNCTION {new.sentence.checka}
{ empty$
    'skip$
    'new.sentence
  if$
}

FUNCTION {new.sentence.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.sentence
  if$
}

%    \end{macrocode}
%
% \section{Formatting chunks}
% Here are some functions for formatting chunks of an entry.
% By convention they either produce a string that can be followed by
% a comma or period (using |add.period$|, so it is OK to end in a period),
% or they produce the null string.
%
% A useful utility is the field.or.null function, which checks if the
% argument is the result of pushing a `missing' field (one for which no
% assignment was made when the current entry was read in from the database)
% or the result of pushing a string having no non-white-space characters.
% It returns the null string if so, otherwise it returns the field string.
% Its main (but not only) purpose is to guarantee that what's left on the
% stack is a string rather than a missing field.
%
% \begin{lstlisting}
% field.or.null(s) ==
%  BEGIN
%       if empty$(s) then return ""
%       else return s
%  END
% \end{lstlisting}
%
% Another helper function is emphasize, which returns the argument emphazised,
% if that is non-empty, otherwise it returns the null string.  Italic
% corrections aren't used, so this function should be used when punctation
% will follow the result.
%
% \begin{lstlisting}
% emphasize(s) ==
%  BEGIN
%       if empty$(s) then return ""
%       else return "{\em " * s * "}"
% \begin{lstlisting}
%
% The format.names function formats the argument (which should be in
% BibTeX name format) into "First Von Last, Junior", separated by commas
% and with an "and" before the last (but ending with "et~al." if the last
% of multiple authors is "others").  This function's argument should always
% contain at least one name.
%
% VAR: nameptr, namesleft, numnames: INTEGER
% pseudoVAR: nameresult: STRING         (it's what's accumulated on the stack)
%
% \begin{lstlisting}
% format.names(s) ==
%  BEGIN
%       nameptr := 1
%       numnames := num.names$(s)
%       namesleft := numnames
%       while namesleft > 0
%         do
%                               % for full names:
%           t := format.name$(s, nameptr, "{ff~}{vv~}{ll}{, jj}")
%                               % for abbreviated first names:
%           t := format.name$(s, nameptr, "{f.~}{vv~}{ll}{, jj}")
%           if nameptr > 1 then
%               if namesleft > 1 then nameresult := nameresult * ", " * t
%               else if numnames > 2
%                      then nameresult := nameresult * ","
%                    fi
%                    if t = "others"
%                      then nameresult := nameresult * " et~al."
%                      else nameresult := nameresult * " and " * t
%                    fi
%               fi
%           else nameresult := t
%           fi
%           nameptr := nameptr + 1
%           namesleft := namesleft - 1
%         od
%       return nameresult
%  END
% \end{lstlisting}
%
% The format.authors function returns the result of format.names(author)
% if the author is present, or else it returns the null string
%
% \begin{lstlisting}
% format.authors ==
%  BEGIN
%       if empty$(author) then return ""
%       else return format.names(author)
%       fi
%  END
% \end{lstlisting}
%
% Format.editors is like format.authors, but it uses the editor field,
% and appends ", editor" or ", editors"
%
% \begin{lstlisting}
% format.editors ==
%  BEGIN
%       if empty$(editor) then return ""
%       else
%           if num.names$(editor) > 1 then
%               return format.names(editor) * ", editors"
%           else
%               return format.names(editor) * ", editor"
%           fi
%       fi
%  END
% \end{lstlisting}
%
% Other formatting functions are similar, so no "comment version" will be
% given for them.
%
% The `pop\$' in this function gets rid of the duplicate `empty' value and
% the `skip\$' returns the duplicate field value
%
%    \begin{macrocode}
FUNCTION {field.or.null}
{ duplicate$ empty$
    { pop$ "" }
    'skip$
  if$
}

FUNCTION {emphasize}
{ duplicate$ empty$
    { pop$ "" }
    { "\emph{" swap$ * "}" * }
  if$
}

FUNCTION {is.in.chinese}
{ lang lang.zh =
}

FUNCTION {format.et.al}
{ is.in.chinese
    { "等"}
    { "et~al." }
  if$
}

FUNCTION {format.anonymous}
{ is.in.chinese
    { "佚名"}
    { "Anon, " year * }
  if$
}

INTEGERS { nameptr namesleft numnames }

FUNCTION {format.names}
{ 's :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > nameptr #4 < and }
    { s nameptr "{vv~}{ll}{ f{ }}{ jj}" format.name$ 't :=
      nameptr #1 >
        { namesleft #1 >
            { ", " * t * }
            { t "others" =
                { ", " * format.et.al * }
                { ", " * t * }
              if$
            }
          if$
          nameptr #3 = namesleft #1 > and
            { ", " * format.et.al * }
            'skip$
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {format.key}
{ empty$
    { key field.or.null }
    { "" }
  if$
}

FUNCTION {format.authors}
{ author empty$
%<authoryear>    { format.anonymous }
%<numerical>    { "" }
    { author format.names }
  if$
}

FUNCTION {format.editors}
{ editor empty$
    { "" }
    { editor format.names
    }
  if$
}

FUNCTION {format.translators}
{ translator empty$
    { "" }
    { translator format.names
      is.in.chinese
        { ",译" * }
        'skip$
      if$
    }
  if$
}

FUNCTION {format.isbn}
{ isbn empty$
    { "" }
    { new.block "ISBN " isbn * }
  if$
}

FUNCTION {format.issn}
{ issn empty$
    { "" }
    { new.block "ISSN " issn * }
  if$
}

FUNCTION {format.url}
{ url empty$
    { "" }
    { new.block "\url{" url * "}" * }
  if$
}

FUNCTION {format.doi}
{ doi empty$
    { "" }
    { new.block "\doi{" doi * "}" * }
  if$
}

%    \end{macrocode}
%
% The format.title function is used for non-book-like titles.
% For most styles we convert to lowercase (except for the very first letter,
% and except for the first one after a colon (followed by whitespace)),
% and hope the user has brace-surrounded words that need to stay capitilized;
% for some styles, however, we leave it as it is in the database.
%
%    \begin{macrocode}
FUNCTION {format.title}
{ title empty$
    { "" }
    { title "t" change.case$ }
  if$
}

FUNCTION {format.mark}
{ mark empty$
    'skip$
    { pop$ mark }
  if$
  "[" swap$ *
  media empty$
    { url empty$
        'skip$
        { "/OL" * }
      if$
    }
    { "/" * media * }
  if$
  "]" *
}

FUNCTION {format.full.names}
{'s :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      "{vv~}{ll}" format.name$ 't :=
      nameptr #1 >
        {
          namesleft #1 >
            { ", " * t * }
            {
              numnames #2 >
                { "," * }
                'skip$
              if$
              t "others" =
                { " et~al." * }
                { " and " * t * }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {author.editor.full}
{ author empty$
    { editor empty$
        { "" }
        { editor format.full.names }
      if$
    }
    { author format.full.names }
  if$
}

FUNCTION {author.full}
{ author empty$
    { "" }
    { author format.full.names }
  if$
}

FUNCTION {editor.full}
{ editor empty$
    { "" }
    { editor format.full.names }
  if$
}

FUNCTION {make.full.names}
{ type$ "book" =
  type$ "inbook" =
  or
    'author.editor.full
    { type$ "proceedings" =
        'editor.full
        'author.full
      if$
    }
  if$
}

FUNCTION {output.bibitem}
{ newline$
  "\bibitem[" write$
  label write$
  ")" make.full.names duplicate$ short.list =
     { pop$ }
     { * }
   if$
  "]{" * write$
  cite$ write$
  "}" write$
  newline$
  ""
  before.all 'output.state :=
}

%    \end{macrocode}
%
% By default, BibTeX sets the global integer variable |global.max$| to the BibTeX
% constant |glob_str_size|, the maximum length of a global string variable.
% Analogously, BibTeX sets the global integer variable |entry.max$| to
% |ent_str_size|, the maximum length of an entry string variable.
% The style designer may change these if necessary (but this is unlikely)

% The n.dashify function makes each single |`-'| in a string a double |`--'|
% if it's not already
%
% \begin{lstlisting}
% pseudoVAR: pageresult: STRING         (it's what's accumulated on the stack)
%
% n.dashify(s) ==
%  BEGIN
%       t := s
%       pageresult := ""
%       while (not empty$(t))
%         do
%           if (first character of t = "-")
%             then
%               if (next character isn't)
%                 then
%                   pageresult := pageresult * "--"
%                   t := t with the "-" removed
%                 else
%                   while (first character of t = "-")
%                     do
%                       pageresult := pageresult * "-"
%                       t := t with the "-" removed
%                     od
%               fi
%             else
%               pageresult := pageresult * the first character
%               t := t with the first character removed
%           fi
%         od
%       return pageresult
%  END
% \end{lstlisting}
%
%    \begin{macrocode}
FUNCTION {n.dashify}
{ 't :=
  ""
    { t empty$ not }
    { t #1 #1 substring$ "-" =
        { t #1 #2 substring$ "--" = not
            { "--" *
              t #2 global.max$ substring$ 't :=
            }
            {   { t #1 #1 substring$ "-" = }
                { "-" *
                  t #2 global.max$ substring$ 't :=
                }
              while$
            }
          if$
        }
        { t #1 #1 substring$ *
          t #2 global.max$ substring$ 't :=
        }
      if$
    }
  while$
}

%    \end{macrocode}
%
% The format.date function is for the month and year, but we give a warning if
% there's an empty year but the month is there, and we return the empty string
% if they're both empty.
%
%    \begin{macrocode}
FUNCTION {format.date}
{ year duplicate$ empty$
    { "empty year in " cite$ * warning$
       pop$ "" }
    'skip$
  if$
  month empty$
    'skip$
    { month
      " " * swap$ *
    }
  if$
  extra.label *
}

FUNCTION {format.editdate}
{ editdate empty$
    { "" }
    { "(" citedate * ")" * }
  if$
}

FUNCTION {format.citedate}
{ citedate empty$
    { "" }
    { "[" citedate * "]" * }
  if$
}

%    \end{macrocode}
%
% The format.date function is for the month and year, but we give a warning if
% there's an empty year but the month is there, and we return the empty string
% if they're both empty.
%
%    \begin{macrocode}
FUNCTION {format.btitle}
{ title emphasize
}

%    \end{macrocode}
%
% For several functions we'll need to connect two strings with a
% tie (~) if the second one isn't very long (fewer than 3 characters).
% The tie.or.space.connect function does that.  It concatenates the two
% strings on top of the stack, along with either a tie or space between
% them, and puts this concatenation back onto the stack:
%
% \begin{lstlisting}
% tie.or.space.connect(str1,str2) ==
%    BEGIN
%       if text.length$(str2) < 3
%         then return the concatenation of str1, "~", and str2
%         else return the concatenation of str1, " ", and str2
%    END
% \end{lstlisting}
%
%    \begin{macrocode}
FUNCTION {tie.or.space.connect}
{ duplicate$ text.length$ #3 <
    { "~" }
    { " " }
  if$
  swap$ * *
}

%    \end{macrocode}
%
% The either.or.check function complains if both fields or an either-or pair
% are nonempty.
%
% \begin{lstlisting}
% either.or.check(t,s) ==
%  BEGIN
%       if empty$(s) then
%           warning$(can't use both " * t * " fields in " * cite$)
%       fi
%  END
% \end{lstlisting}
%
%    \begin{macrocode}
FUNCTION {either.or.check}
{ empty$
    'pop$
    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
  if$
}

FUNCTION {is.digit}
{ duplicate$ empty$
    { pop$ #0 }
    { chr.to.int$
      duplicate$ "0" chr.to.int$ <
      { pop$ #0 }
      { "9" chr.to.int$ >
          { #0 }
          { #1 }
        if$
      }
    if$
    }
  if$
}

INTEGERS { charptr stringlength }

FUNCTION {is.number}
{ 's :=
  s empty$
    { #0 }
    { s text.length$ 'charptr :=
        { charptr #0 >
          s charptr #1 substring$ is.digit
          and
        }
        { charptr #1 - 'charptr := }
      while$
      charptr not
    }
  if$
}

%    \end{macrocode}
%
% The format.bvolume function is for formatting the volume and perhaps
% series name of a multivolume work.  If both a volume and a series field
% are there, we assume the series field is the title of the whole multivolume
% work (the title field should be the title of the thing being referred to),
% and we add an "of <series>".  This function is called in mid-sentence.
%
%    \begin{macrocode}
FUNCTION {format.bvolume}
{ volume empty$
    { "" }
    { volume is.number
        { is.in.chinese
            { "第" volume * "卷" * }
            { "volume" volume tie.or.space.connect }
          if$
        }
        { volume }
      if$
    }
  if$
}

FUNCTION {format.number}
{ number empty$
    { "" }
    { number is.number
        { is.in.chinese
            { "第" volume * "册" * }
            { "number" number tie.or.space.connect }
          if$
        }
        { number }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The format.number.series function is for formatting the series name
% and perhaps number of a work in a series.  This function is similar to
% format.bvolume, although for this one the series must exist (and the
% volume must not exist).  If the number field is empty we output either
% the series field unchanged if it exists or else the null string.
% If both the number and series fields are there we assume the series field
% gives the name of the whole series (the title field should be the title
% of the work being one referred to), and we add an "in <series>".
% We capitilize Number when this function is used at the beginning of a block.
%
%    \begin{macrocode}
FUNCTION {format.number.series}
{ volume empty$
    { number empty$
        { series field.or.null }
        { output.state mid.sentence =
            { "number" }
            { "Number" }
          if$
          number tie.or.space.connect
          series empty$
            { "there's a number but no series in " cite$ * warning$ }
            { " in " * series * }
          if$
        }
      if$
    }
    { "" }
  if$
}

FUNCTION {format.series.volume.title}
{ series empty$
    { title
      volume empty$
        'skip$
        { ": " * format.bvolume * }
      if$
    }
    { series
      volume empty$
        { number empty$
          'skip$
          { ": " * format.number * }
        if$ }
        { volume empty$
          'skip$
          { ": " * format.bvolume * }
        if$
        }
      if$
      "\hspace{1em}" * title *
    }
  if$
}

FUNCTION {num.to.ordinal}
{ duplicate$ text.length$ 'charptr :=
  duplicate$ charptr #1 substring$ 's :=
  s "1" =
    { "st" * }
    { s "2" =
        { "nd" * }
        { s "3" =
            { "rd" * }
            { "th" * }
          if$
        }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The format.edition function appends " edition" to the edition, if present.
% We lowercase the edition (it should be something like "Third"), because
% this doesn't start a sentence.
%
%    \begin{macrocode}
FUNCTION {format.edition}
{ edition empty$
    { "" }
    { edition is.number
        { is.in.chinese
            { edition "版" * }
            { edition num.to.ordinal " ed." * }
          if$
        }
        { edition "t" change.case$
          edition "Revised" =
            { "Rev. ed." }
            { edition "Revised edition" =
                { "Rev. ed." }
                'skip$
              if$
            }
          if$
         }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The format.pages function is used for formatting a page range in a book
% (and in rare circumstances, an article).
%
% The multi.page.check function examines the page field for a "-" or "," or "+"
% so that format.pages can use "page" instead of "pages" if none exists.
% Note: |global.max$| here means "take the rest of the string"
%
% \begin{lstlisting}
% VAR: multiresult: INTEGER     (actually, a boolean)
%
% multi.page.check(s) ==
%  BEGIN
%       t := s
%       multiresult := false
%       while ((not multiresult) and (not empty$(t)))
%         do
%           if (first character of t = "-" or "," or "+")
%             then multiresult := true
%             else t := t with the first character removed
%           fi
%         od
%       return multiresult
%  END
% \end{lstlisting}
%
%    \begin{macrocode}
FUNCTION {format.address}
{ address empty$
    { url empty$
        { is.in.chinese
            { "[出版地不详]" }
            { "[S.l.]" }
          if$
        }
        { "" }
      if$
    }
    { address }
  if$
}

FUNCTION {format.publisher}
{ publisher empty$
    { url empty$
        { is.in.chinese
            { "[出版者不详]" }
            { "[s.n.]" }
          if$
        }
        { "" }
      if$
    }
    { publisher }
  if$
}

INTEGERS { multiresult }

FUNCTION {multi.page.check}
{ 't :=
  #0 'multiresult :=
    { multiresult not
      t empty$ not
      and
    }
    { t #1 #1 substring$
      duplicate$ "-" =
      swap$ duplicate$ "," =
      swap$ "+" =
      or or
        { #1 'multiresult := }
        { t #2 global.max$ substring$ 't := }
      if$
    }
  while$
  multiresult
}

%    \end{macrocode}
%
% This function doesn't begin a sentence so "pages" isn't capitalized.
% Other functions that use this should keep that in mind.
%
%    \begin{macrocode}
FUNCTION {format.pages}
{ pages empty$
    { "" }
    { pages }
  if$
}

FUNCTION {format.eid}
{ eid empty$
    { "" }
    { "art." eid tie.or.space.connect }
  if$
}

%    \end{macrocode}
%
% The format.vol.num.pages function is for the volume, number, and page range
% of a journal article.  We use the format:  vol(number):pages, with some
% variations for empty fields.  This doesn't begin a sentence.
%
%    \begin{macrocode}
FUNCTION {format.vol.num.pages}
{ volume field.or.null
  number empty$
    'skip$
    { "\penalty0 (" number * ")" * *
      volume empty$
        { "there's a number but no volume in " cite$ * warning$ }
        'skip$
      if$
    }
  if$
  pages empty$
    'skip$
    { duplicate$ empty$
        { pop$ format.pages }
        { ":\penalty0 " * pages n.dashify * }
      if$
    }
  if$
}

FUNCTION {format.vol.num.eid}
{ volume field.or.null
  number empty$
    'skip$
    { "\penalty0 (" number * ")" * *
      volume empty$
        { "there's a number but no volume in " cite$ * warning$ }
        'skip$
      if$
    }
  if$
  eid empty$
    'skip$
    { duplicate$ empty$
        { pop$ format.eid }
        { ":\penalty0 " * eid * }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The format.chapter.pages, if the chapter is present, puts whatever is in the
% type field (or else "chapter" if type is empty) in front of a chapter number.
% It then appends the pages, if present.  This doesn't begin a sentence.
%
%    \begin{macrocode}
FUNCTION {format.chapter.pages}
{ chapter empty$
    'format.pages
    { type empty$
        { "chapter" }
        { type "l" change.case$ }
      if$
      chapter tie.or.space.connect
      pages empty$
        'skip$
        { ", " * format.pages * }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The format.in.ed.booktitle function is used for starting out a sentence
% that begins "In <booktitle>", putting an editor before the title if one
% exists.
%
%    \begin{macrocode}
FUNCTION {format.in.ed.booktitle}
{ booktitle empty$
    { "" }
    { editor empty$
        { "In " booktitle emphasize * }
        { "In " format.editors * ", " * booktitle emphasize * }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The function empty.misc.check complains if all six fields are empty, and
% if there's been no sorting or alphabetic-label complaint.
%
%    \begin{macrocode}
FUNCTION {empty.misc.check}
{ author empty$ title empty$ howpublished empty$
  month empty$ year empty$ note empty$
  and and and and and
  key empty$ not and
    { "all relevant fields are empty in " cite$ * warning$ }
    'skip$
  if$
}

%    \end{macrocode}
%
% The function format.thesis.type returns either the (case-changed) type field,
% if it is defined, or else the default string already on the stack
% (like "Master's thesis" or "PhD thesis").
%
%    \begin{macrocode}
FUNCTION {format.thesis.type}
{ type empty$
    'skip$
    { pop$
      type "t" change.case$
    }
  if$
}

%    \end{macrocode}
%
% The function format.tr.number makes a string starting with "Technical Report"
% (or type, if that field is defined), followed by the number if there is one;
% it returns the starting part (with a case change) even if there is no number.
% This is used at the beginning of a sentence.
%
%    \begin{macrocode}
FUNCTION {format.tr.number}
{ type empty$
    { "Technical Report" }
    'type
  if$
  number empty$
    { "t" change.case$ }
    { number tie.or.space.connect }
  if$
}

%    \end{macrocode}
%
% Now come the cross-referencing functions (these are invoked because
% one entry in the database file(s) cross-references another, by giving
% the other entry's database key in a `crossref' field).  This feature
% allows one or more titled things that are part of a larger titled
% thing to cross-reference the larger thing.  These styles allow for
% five posibilities: (1) an ARTICLE may cross-reference an ARTICLE;
% (2) a BOOK, (3) INBOOK, or (4) INCOLLECTION may cross-reference a BOOK;
% or (5) an INPROCEEDINGS may cross-reference a PROCEEDINGS.
% Each of these is explained in more detail later.
%
% An ARTICLE entry type may cross reference another ARTICLE (this is
% intended for when an entire journal is devoted to a single topic---
% but since there is no JOURNAL entry type, the journal, too, should be
% classified as an ARTICLE but without the author and title fields).
% This will result in two warning messages for the journal's entry
% if it's included in the reference list, but such is life.
%
% format.article.crossref ==
%  BEGIN
%       if empty$(key) then
%           if empty$(journal) then
%               warning$("need key or journal for " * cite$ *
%                                               " to crossref " * crossref)
%               return(" \cite{" * crossref * "}")
%           else
%               return("In " * emphazise.correct (journal) *
%                                               " \cite{" * crossref * "}")
%               fi
%       else
%           return("In " * key * " \cite{" * crossref * "}")
%       fi
%  END
%
% The other cross-referencing functions are similar, so no "comment version"
% will be given for them.
%
%    \begin{macrocode}
FUNCTION {format.article.crossref}
{ key empty$
    { journal empty$
        { "need key or journal for " cite$ * " to crossref " * crossref *
          warning$
          ""
        }
        { "In \emph{" journal * "}" * }
      if$
    }
    { "In " }
  if$
  " \citet{" * crossref * "}" *
}

%    \end{macrocode}
%
% A BOOK (or INBOOK) entry type (assumed to be for a single volume in a
% multivolume work) may cross reference another BOOK (the entire multivolume).
% Usually there will be an editor, in which case we use that to construct the
% cross reference; otherwise we use a nonempty key field or else the series
% field (since the series gives the title of the multivolume work).
%
%    \begin{macrocode}
FUNCTION {format.book.crossref}
{ volume empty$
    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
      "In "
    }
    { "Volume" volume tie.or.space.connect
      " of " *
    }
  if$
  editor empty$
  editor field.or.null author field.or.null =
  or
    { key empty$
        { series empty$
            { "need editor, key, or series for " cite$ * " to crossref " *
              crossref * warning$
              "" *
            }
            { "\emph{" * series * "}" * }
          if$
        }
        'skip$
      if$
    }
    'skip$
  if$
  " \citet{" * crossref * "}" *
}

%    \end{macrocode}
%
% An INCOLLECTION entry type may cross reference a BOOK (assumed to be the
% collection), or an INPROCEEDINGS may cross reference a PROCEEDINGS.
% Often there will be an editor, in which case we use that to construct
% the cross reference; otherwise we use a nonempty key field or else
% the booktitle field (which gives the cross-referenced work's title).
%
%    \begin{macrocode}
FUNCTION {format.incoll.inproc.crossref}
{ editor empty$
  editor field.or.null author field.or.null =
  or
    { key empty$
        { booktitle empty$
            { "need editor, key, or booktitle for " cite$ * " to crossref " *
              crossref * warning$
              ""
            }
            { "In \emph{" booktitle * "}" * }
          if$
        }
        { "In " }
      if$
    }
    { "In " }
  if$
  " \citet{" * crossref * "}" *
}

%    \end{macrocode}
%
% \section{Functions for all entry types}
%
% Now we define the type functions for all entry types that may appear
% in the .BIB file---e.g., functions like `article' and `book'.  These
% are the routines that actually generate the .BBL-file output for
% the entry.  These must all precede the READ command.  In addition, the
% style designer should have a function `default.type' for unknown types.
% Note: The fields (within each list) are listed in order of appearance,
% except as described for an `inbook' or a `proceedings'.
%
% The article function is for an article in a journal.  An article may
% CROSSREF another article.
%       Required fields: author, title, journal, year
%       Optional fields: volume, number, pages, month, note
%
% \begin{lstlisting}
% article ==
%  BEGIN
%       output.bibitem
%       output.check(format.authors,"author")
%       new.block
%       output.check(format.title,"title")
%       new.block
%       if missing$(crossref) then
%           output.check(emphasize(journal),"journal")
%           output(format.vol.num.pages)
%           output.check(format.date,"year")
%       else
%           output.nonnull(format.article.crossref)
%           output(format.pages)
%       fi
%       new.block
%       output(note)
%       fin.entry
%  END
% \end{lstlisting}
%
% The book function is for a whole book.  A book may CROSSREF another book.
%       Required fields: author or editor, title, publisher, year
%       Optional fields: volume or number, series, address, edition, month,
%                       note
%
% \begin{lstlisting}
% book ==
%  BEGIN
%       if empty$(author) then output.check(format.editors,"author and editor")
%       else    output.check(format.authors,"author")
%               if missing$(crossref) then
%                   either.or.check("author and editor",editor)
%               fi
%       fi
%       new.block
%       output.check(format.btitle,"title")
%       if missing$(crossref) then
%           output(format.bvolume)
%           new.block
%           output(format.number.series)
%           new.sentence
%           output.check(publisher,"publisher")
%           output(address)
%       else
%           new.block
%           output.nonnull(format.book.crossref)
%       fi
%       output(format.edition)
%       output.check(format.date,"year")
%       new.block
%       output(note)
%       fin.entry
%  END
% \end{lstlisting}
%
% The other entry functions are all quite similar, so no "comment version"
% will be given for them.
%
%    \begin{macrocode}
FUNCTION {archive}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  "A" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  format.publisher punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {article}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block
  format.title "title" output.check
  journal empty$
    { "M" format.mark "" output.after
      new.block
      format.translators output
      new.block
      format.editors punct.slash output.after
      new.block
      booktitle "booktitle" output.check
      new.block
      format.bvolume punct.colon output.after
      new.block
      format.edition output
      new.block
      format.address output
      format.publisher punct.colon output.after
      format.date "year" output.check
      format.pages punct.colon output.after
    }
    { "J" format.mark "" output.after
      new.block
      journal "journal" output.check
      new.block
      format.date "year" output.check
      format.vol.num.pages output
    }
  if$
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {book}
{ output.bibitem
  author empty$
    { format.editors "author and editor" output.check
      editor format.key output
    }
    { format.authors output.nonnull
      crossref missing$
        { "author and editor" editor either.or.check }
        'skip$
      if$
    }
  if$
  new.block
  format.series.volume.title "title" output.check
  "M" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  format.publisher punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {collection}
{ output.bibitem
  author empty$
    { format.editors "author and editor" output.check
      editor format.key output
    }
    { format.authors output.nonnull
      crossref missing$
        { "author and editor" editor either.or.check }
        'skip$
      if$
    }
  if$
  new.block
  format.series.volume.title "title" output.check
  "G" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  format.publisher punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {database}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  "DB" format.mark "" output.after
  new.block
  format.date "year" output.check
  format.editdate "" output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {dataset}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  "DS" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  format.publisher punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.editdate "" output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

%    \end{macrocode}
%
% An inbook is a piece of a book: either a chapter and/or a page range.
% It may CROSSREF a book.  If there's no volume field, the type field
% will come before number and series.
%
%       Required: author or editor, title, chapter and/or pages, publisher,year
%
%       Optional: volume or number, series, type, address, edition, month, note
%
%    \begin{macrocode}
FUNCTION {inbook} { book }

%    \end{macrocode}
%
% An incollection is like inbook, but where there is a separate title
% for the referenced thing (and perhaps an editor for the whole).
% An incollection may CROSSREF a book.
%       Required: author, title, booktitle, publisher, year
%       Optional: editor, volume or number, series, type, chapter, pages,
%                       address, edition, month, note
%
%    \begin{macrocode}
FUNCTION {incollection} { book }

%    \end{macrocode}
%
% An inproceedings is an article in a conference proceedings, and it may
% CROSSREF a proceedings.  If there's no address field, the month (\& year)
% will appear just before note.
%       Required: author, title, booktitle, year
%       Optional: editor, volume or number, series, pages, address, month,
%                       organization, publisher, note
%
%    \begin{macrocode}
FUNCTION {inproceedings}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block
  format.title "title" output.check
  "C" format.mark "" output.after
  new.block
  format.translators output
  new.block
  editor empty$
    { organization }
    { format.editors }
  if$ punct.slash output.after
  new.block
  booktitle "booktitle" output.check
  new.block
  format.bvolume punct.colon output.after
  new.block
  format.edition output
  new.sentence
  format.address output
  publisher empty$
    { organization }
    { format.publisher }
  if$ punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

%    \end{macrocode}
%
% The conference function is included for Scribe compatibility.
%
%    \begin{macrocode}
FUNCTION {conference} { inproceedings }

%    \end{macrocode}
%
% A manual is technical documentation.
%       Required: title
%       Optional: author, organization, address, edition, month, year, note
%
%    \begin{macrocode}
FUNCTION {manual}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  organization address new.block.checkb
  organization output
  format.address output
  format.edition output
  format.date output
  format.url output
  new.block
  note output
  fin.entry
}

FUNCTION {map}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  "CM" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  format.publisher punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

%    \end{macrocode}
%
% A mastersthesis is a Master's thesis.
%       Required: author, title, school, year
%       Optional: type, address, month, note
%
% \changes{v0.9.1}{2016/04/23}{Add school field}
%
%    \begin{macrocode}
FUNCTION {mastersthesis}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  "D" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  school empty$
    { format.publisher }
    { school }
  if$ punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

%    \end{macrocode}
%
% A misc is something that doesn't fit elsewhere.
%       Required: at least one of the `optional' fields
%       Optional: author, title, howpublished, month, year, note
%
%    \begin{macrocode}
FUNCTION {misc}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  "M" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  format.publisher punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {newspaper}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block
  format.title "title" output.check
  "N" format.mark "" output.after
  new.block
  journal "journal" output.check
  new.block
  format.date "year" output.check
  format.vol.num.pages output
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {patent}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.title "title" output.check
  "P" format.mark "" output.after
  new.block
  format.date "year" output.check
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

%    \end{macrocode}
%
% A phdthesis is like a mastersthesis.
%       Required: author, title, school, year
%       Optional: type, address, month, note
%
%    \begin{macrocode}
FUNCTION {phdthesis} { mastersthesis }

%    \end{macrocode}
%
% A proceedings is a conference proceedings.
% If there is an organization but no editor field, the organization will
% appear as the first optional field (we try to make the first block nonempty);
% if there's no address field, the month (\& year) will appear just before note.
%       Required: title, year
%       Optional: editor, volume or number, series, address, month,
%                       organization, publisher, note
%
%    \begin{macrocode}
FUNCTION {proceedings}
{ output.bibitem
  format.editors output
  editor format.key output
  new.block
  format.series.volume.title "title" output.check
  "C" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  publisher empty$
    { organization }
    { format.publisher }
  if$ punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {program}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  "CP" format.mark "" output.after
  new.block
  format.date "year" output.check
  format.editdate "" output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

FUNCTION {standard}
{ output.bibitem
  format.authors output
  author format.key output
  new.block
  format.series.volume.title "title" output.check
  "S" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  format.publisher punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

%    \end{macrocode}
%
% A techreport is a technical report.
%       Required: author, title, institution, year
%       Optional: type, number, address, month, note
%
% \changes{v0.9.1}{2016/04/24}{Fix empty author bug}
%
%    \begin{macrocode}
FUNCTION {techreport}
{ output.bibitem
  author empty$
    { institution output
      institution format.key output
    }
    { format.authors output
      author format.key output
    }
  if$
  new.block
  format.series.volume.title "title" output.check
  "R" format.mark "" output.after
  new.block
  format.translators output
  new.block
  format.edition output
  new.sentence
  format.address output
  format.publisher punct.colon output.after
  format.date "year" output.check
  format.pages punct.colon output.after
  format.editdate "" output.after
  format.citedate "" output.after
  format.url output
  format.doi output
  fin.entry
}

%    \end{macrocode}
%
% An unpublished is something that hasn't been published.
%       Required: author, title, note
%       Optional: month, year
%
%    \begin{macrocode}
FUNCTION {unpublished}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  new.block
  format.title "title" output.check
  new.block
  note "note" output.check
  format.date output
  format.url output
  fin.entry
}

%    \end{macrocode}
%
% We use entry type `misc' for an unknown type; BibTeX gives a warning.
%
%    \begin{macrocode}
FUNCTION {default.type} { misc }

%    \end{macrocode}
%
% \section{Common macros}
%
% Here are macros for common things that may vary from style to style.
% Users are encouraged to use these macros.
%
% Months are either written out in full or abbreviated
%
%    \begin{macrocode}
MACRO {jan} {"January"}

MACRO {feb} {"February"}

MACRO {mar} {"March"}

MACRO {apr} {"April"}

MACRO {may} {"May"}

MACRO {jun} {"June"}

MACRO {jul} {"July"}

MACRO {aug} {"August"}

MACRO {sep} {"September"}

MACRO {oct} {"October"}

MACRO {nov} {"November"}

MACRO {dec} {"December"}

%    \end{macrocode}
%
% Journals are either written out in full or abbreviated;
% the abbreviations are like those found in ACM publications.
%
% To get a completely different set of abbreviations, it may be best to make
% a separate .bib file with nothing but those abbreviations; users could then
% include that file name as the first argument to the \bibliography command
%
%    \begin{macrocode}
MACRO {acmcs} {"ACM Computing Surveys"}

MACRO {acta} {"Acta Informatica"}

MACRO {cacm} {"Communications of the ACM"}

MACRO {ibmjrd} {"IBM Journal of Research and Development"}

MACRO {ibmsj} {"IBM Systems Journal"}

MACRO {ieeese} {"IEEE Transactions on Software Engineering"}

MACRO {ieeetc} {"IEEE Transactions on Computers"}

MACRO {ieeetcad}
 {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}

MACRO {ipl} {"Information Processing Letters"}

MACRO {jacm} {"Journal of the ACM"}

MACRO {jcss} {"Journal of Computer and System Sciences"}

MACRO {scp} {"Science of Computer Programming"}

MACRO {sicomp} {"SIAM Journal on Computing"}

MACRO {tocs} {"ACM Transactions on Computer Systems"}

MACRO {tods} {"ACM Transactions on Database Systems"}

MACRO {tog} {"ACM Transactions on Graphics"}

MACRO {toms} {"ACM Transactions on Mathematical Software"}

MACRO {toois} {"ACM Transactions on Office Information Systems"}

MACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}

MACRO {tcs} {"Theoretical Computer Science"}

%    \end{macrocode}
%
% \section{Read bib entries and execute}
%
% Now we read in the .BIB entries.
%
%    \begin{macrocode}
READ

EXECUTE {init.state.consts}

INTEGERS { ascii }

FUNCTION {char.lang}
{ chr.to.int$ 'ascii :=
  ascii #31 > ascii #128 < and
    { lang.en }
    { ascii #227 > ascii #234 < and
        { lang.zh }
        { ascii #227 =
            { lang.ja }
            { lang.default }
          if$
        }
      if$
    }
  if$
}

FUNCTION {set.language}
{ language empty$
    { lang.default 'lang :=
      author field.or.null title field.or.null * 's :=
      s empty$
        'skip$
        { #1 'charptr :=
          s text.length$ #1 + 'stringlength :=
            { charptr stringlength < }
            { s charptr #1 substring$ char.lang
              duplicate$ #3 >
                { charptr #2 + 'charptr := }
                'skip$
              if$
              duplicate$ lang >
                { 'lang := }
                'pop$
              if$
              charptr #1 + 'charptr :=
            }
          while$
        }
      if$
    }
    { language "en" =
        { lang.en }
        { language "zh" =
            { lang.zh }
            { language "ja" =
                { lang.ja }
                { lang.default }
              if$
            }
          if$
        }
      if$
      'lang :=
    }
  if$
}

%    \end{macrocode}
%
% The sortify function converts to lower case after |purify$|ing; it's
% used in sorting and in computing alphabetic labels after sorting
%
% The chop.word(w,len,s) function returns either s or, if the first len
% letters of s equals w (this comparison is done in the third line of the
% function's definition), it returns that part of s after w.
%
%    \begin{macrocode}
FUNCTION {sortify}
{ purify$
  "l" change.case$
}

%    \end{macrocode}
%
% We need the chop.word stuff for the dubious unsorted-list-with-labels case.
%
%    \begin{macrocode}
INTEGERS { len }

FUNCTION {chop.word}
{ 's :=
  'len :=
  s #1 len substring$ =
    { s len #1 + global.max$ substring$ }
    's
  if$
}

FUNCTION {format.lab.names}
{ 's :=
  s #1 "{vv~}{ll}" format.name$
  s num.names$ #1 >
    { ", " * format.et.al * }
    'skip$
  if$
}

FUNCTION {author.key.label}
{ author empty$
    { key empty$
        { cite$ #1 #3 substring$ }
        'key
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.editor.key.label}
{ author empty$
    { editor empty$
        { key empty$
            { cite$ #1 #3 substring$ }
            'key
          if$
        }
        { editor format.lab.names }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.key.organization.label}
{ author empty$
    { key empty$
        { organization empty$
            { cite$ #1 #3 substring$ }
            { "The " #4 organization chop.word #3 text.prefix$ }
          if$
        }
        'key
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {editor.key.organization.label}
{ editor empty$
    { key empty$
        { organization empty$
            { cite$ #1 #3 substring$ }
            { "The " #4 organization chop.word #3 text.prefix$ }
          if$
        }
        'key
      if$
    }
    { editor format.lab.names }
  if$
}

FUNCTION {calc.short.authors}
{ type$ "book" =
  type$ "inbook" =
  or
    'author.editor.key.label
    { type$ "proceedings" =
        'editor.key.organization.label
        { type$ "manual" =
            'author.key.organization.label
            'author.key.label
          if$
        }
      if$
    }
  if$
  'short.list :=
}

FUNCTION {calc.label}
{ calc.short.authors
  short.list
  "("
  *
  year duplicate$ empty$
  short.list key field.or.null = or
     { pop$ "" }
     'skip$
  if$
  *
  'label :=
}

%<*authoryear>
FUNCTION {sort.language.label}
{ lang lang.zh =
    { "a   "
      pinyin empty$
        'skip$
        { pinyin * "   " * }
      if$
    }
    { lang lang.ja =
        { "b   " }
        { lang lang.en =
            { "c   " }
            { lang lang.ru =
                { "d   " }
                { "e   " }
              if$
            }
          if$
        }
      if$
    }
  if$
}

%    \end{macrocode}
%
% When sorting, we compute the sortkey by executing "presort" on each entry.
% The presort key contains a number of "sortify"ed strings, concatenated
% with multiple blanks between them.  This makes things like "brinch  per"
% come before "brinch hansen  per".
%
% The fields used here are: the sort.label for alphabetic labels (as set by
% calc.label), followed by the author names (or editor names or organization
% (with a leading "The " removed) or key field, depending on entry type and on
% what's empty), followed by year, followed by the first bit of the title
% (chopping off a leading "The ", "A ", or "An ").
% Names are formatted: Von Last First Junior.
% The names within a part will be separated by a single blank
% (such as "brinch hansen"), two will separate the name parts themselves
% (except the von and last), three will separate the names,
% four will separate the names from year (and from label, if alphabetic),
% and four will separate year from title.
%
% The sort.format.names function takes an argument that should be in
% BibTeX name format, and returns a string containing "   "-separated
% names in the format described above.  The function is almost the same
% as format.names.
%
%    \begin{macrocode}
FUNCTION {sort.format.names}
{ 's :=
  #1 'nameptr :=
  sort.language.label
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    {
      s nameptr "{vv{ } }{ll{ }}{  ff{ }}{  jj{ }}" format.name$ 't :=
      nameptr #1 >
        {
          "   "  *
          namesleft #1 = t "others" = and
            { "zzzzz" * }
            { numnames #2 > nameptr #2 = and
                { "zz" * year field.or.null * "   " * }
                'skip$
              if$
              t sortify *
            }
          if$
        }
        { t sortify * }
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

%    \end{macrocode}
%
% The sort.format.title function returns the argument,
% but first any leading "A "'s, "An "'s, or "The "'s are removed.
% The chop.word function uses s, so we need another string variable, t
%
%    \begin{macrocode}
FUNCTION {sort.format.title}
{ 't :=
  "A " #2
    "An " #3
      "The " #4 t chop.word
    chop.word
  chop.word
  sortify
  #1 global.max$ substring$
}

%    \end{macrocode}
%
% The auxiliary functions here, for the presort function, are analogous to
% the ones for calc.label; the same comments apply, except that the
% organization field takes precedence here over the key field.  For sorting
% purposes, we still remove a leading "The " from the organization field.
%
%    \begin{macrocode}
FUNCTION {author.sort}
{ author empty$
    { key empty$
        { format.anonymous }
        { key sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.editor.sort}
{ author empty$
    { editor empty$
        { key empty$
            { "to sort, need author, editor, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { editor sort.format.names }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.organization.sort}
{ author empty$
    { organization empty$
        { key empty$
            { "to sort, need author, organization, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {editor.organization.sort}
{ editor empty$
    { organization empty$
        { key empty$
            { "to sort, need editor, organization, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { editor sort.format.names }
  if$
}

%</authoryear>
%<*numerical>
INTEGERS { seq.num }

FUNCTION {init.seq}
{ #0 'seq.num :=}

EXECUTE {init.seq}

FUNCTION {int.to.fix}{ "000000000" swap$ int.to.str$ *
  #-1 #10 substring$}

%</numerical>
%    \end{macrocode}
%
% There is a limit, entry.max$, on the length of an entry string variable
% (which is what its sort.key$ is), so we take at most that many characters
% of the constructed key, and hope there aren't many references that match
% to that many characters!
%
%    \begin{macrocode}
FUNCTION {presort}
{ set.language
  calc.label
  label sortify
  "    "
  *
%<*authoryear>
  type$ "book" =
  type$ "inbook" =
  or
    'author.editor.sort
    { type$ "proceedings" =
        'editor.organization.sort
        { type$ "manual" =
            'author.organization.sort
            'author.sort
          if$
        }
      if$
    }
  if$
  "    "
  *
  year field.or.null sortify
  *
  "    "
  *
  cite$
  *
  #1 entry.max$ substring$
%</authoryear>
%<*numerical>
  seq.num #1 + 'seq.num :=  seq.num  int.to.fix
%</numerical>
  'sort.label :=
  sort.label *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {presort}

SORT

STRINGS { longest.label last.label next.extra }

INTEGERS { longest.label.width last.extra.num number.label }

FUNCTION {initialize.longest.label}
{ "" 'longest.label :=
  #0 int.to.chr$ 'last.label :=
  "" 'next.extra :=
  #0 'longest.label.width :=
  #0 'last.extra.num :=
  #0 'number.label :=
}

FUNCTION {forward.pass}
{ last.label label =
    { last.extra.num #1 + 'last.extra.num :=
      last.extra.num int.to.chr$ 'extra.label :=
    }
    { "a" chr.to.int$ 'last.extra.num :=
      "" 'extra.label :=
      label 'last.label :=
    }
  if$
  number.label #1 + 'number.label :=
}

FUNCTION {reverse.pass}
{ next.extra "b" =
    { "a" 'extra.label := }
    'skip$
  if$
  extra.label 'next.extra :=
  extra.label
  duplicate$ empty$
    'skip$
    { "{\natexlab{" swap$ * "}}" * }
  if$
  'extra.label :=
  label extra.label * 'label :=
}

EXECUTE {initialize.longest.label}

ITERATE {forward.pass}

REVERSE {reverse.pass}

FUNCTION {bib.sort.order}
{ sort.label  'sort.key$ :=
}

ITERATE {bib.sort.order}

SORT

%    \end{macrocode}
%
% Now we're ready to start writing the .BBL file.
% We begin, if necessary, with a LaTeX macro for unnamed names in an alphabetic
% label; next comes stuff from the `preamble' command in the database files.
% Then we give an incantation containing the command
%     |\begin{thebibliography}{...}|
% where the `...' is the longest label.
%
% We also call init.state.consts, for use by the output routines.
%
% \changes{v0.9.1}{2016/04/23}{Make doi uppercase}
%
%    \begin{macrocode}
FUNCTION {begin.bib}
{   preamble$ empty$
    'skip$
    { preamble$ write$ newline$ }
  if$
  "\begin{thebibliography}{" number.label int.to.str$ * "}" *
  write$ newline$
  "\providecommand{\natexlab}[1]{#1}"
  write$ newline$
  "\providecommand{\url}[1]{\texttt{#1}}"
  write$ newline$
  "\expandafter\ifx\csname urlstyle\endcsname\relax"
  write$ newline$
  "  \providecommand{\doi}[1]{DOI: #1}\else"
  write$ newline$
  "  \providecommand{\doi}{DOI: \begingroup \urlstyle{rm}\Url}\fi"
  write$ newline$
}

EXECUTE {begin.bib}

%    \end{macrocode}
%
% Now we produce the output for all the entries
%
%    \begin{macrocode}
ITERATE {call.type$}

%    \end{macrocode}
%
% Finally, we finish up by writing the `|\end{thebibliography}|' command.
%
%    \begin{macrocode}
FUNCTION {end.bib}
{ newline$
  "\end{thebibliography}" write$ newline$
}

EXECUTE {end.bib}
%</authoryear|numerical>
%    \end{macrocode}
%
% \Finale
\endinput
